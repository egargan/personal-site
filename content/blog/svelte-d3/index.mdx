---
title: How to use D3 with Svelte
created: "2025-08-24"
updated: "2025-08-24"
tags: ["svelte", "info vis"]
readTimeMins: 3
status: draft
intro: D3
---
import IntroDemo from "./IntroDemo.astro";
import SvelteChartCodeBlock from "./SvelteChartCodeBlock.astro";
import DrawTransitionsDemo from "./DrawTransitionDemo.astro";
import ReactivityDemo from "./ReactivityDemo.astro";
import TweenDemo from "./TweenDemo.astro";
import TweenData from "./TweenData.astro";
import Code from "$components/blog/Code.astro";
import "./transfer-chart.css"

<aside>
TODO: add tab to initial demo with data?<br/>
</aside>

14 years after its release in 2011, [D3](https://d3js.org/) is still a foundational tool for data
visualisation on the web.

Simple line charts, complex interactive maps ([like this
one](https://www.theguardian.com/us-news/ng-interactive/2024/nov/06/us-election-results-map-2024-live-donald-trump-kamala-harris-president)),
and everything in between: D3's doing most of the complicated work for you.

Part of D3's appeal is its DOM manipulation API ([d3-selection](https://d3js.org/d3-selection)),
which makes it easy to build SVG visualisations from the data you're working with.

Here's a simple example. This code imports data from a JSON file, then populates an empty `<svg>` element with `<path>`, `<line>`, etc. elements mapped from the data.

<IntroDemo/>

But things have changed a bit since D3 was released. These days we're usually building
websites with React, Vue, or Svelte (if you're cool enough).

To make the code above work inside these frameworks, we wait for our components to be
mounted to the DOM before asking D3 to do its thing.

In Svelte, we do this with <mark class="purple">`onMount`</mark> (equivalent to React's `useEffect`).

```svelte purple:/onMount/
<script>
  // fold-start
  import * as d3 from "d3";
  import transfers from "./transfers-top-spenders.json";
  // fold-end

  onMount(() => {
    const margin = { right: 20, top: 10, left: 40, bottom: 20 };
    const width = 420 - margin.left - margin.right;
    const height = 280 - margin.top - margin.bottom;

    const seasons = [...new Set(transfers.map((d) => d.season))];

    // fold-start
    const x = d3.scalePoint().domain(seasons).range([0, width]);
    const y = d3.scaleLinear().domain([0, 700]).range([height, 0]);
    const line = d3.line().x((d) => x(d.season)).y((d) => y(d.spend));

    const svg = d3.select("#transfer-window")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.bottom + margin.top)
      .append("g")
      .attr("transform", `translate(${margin.left},${margin.top})`);

    svg.selectAll()
      .data(d3.group(transfers, (d) => d.team))
      .join("path")
      .attr("d", ([_, values]) => line(values))
      .attr("data-team", ([team]) => team)

    svg.append("g").call(d3.axisLeft(y));
    svg.append("g")
      .attr("transform", `translate(0,${height})`)
      .call(d3.axisBottom(x));
  })
  // fold-end
</script>

<svg id="transfer-window"></svg>
```

This works, and it's what I often see in code that uses D3 in Svelte.

But really, we should be asking Svelte to render our elements, not D3. That's Svelte's job after all. [D3's own getting started guide](https://d3js.org/getting-started#d3-in-svelte) tells us as much.

And not just because it's _cleaner_ or _more consistent_ &mdash; there are tangible benefits: better performance, easier reactivity, easier animations.

I'll talk more about the benefits further down, but first, let's have a look it looks like to do things _properly_.

<SvelteChartCodeBlock/>

Looking at the key bits of code:

* for each team's data in `transfers`, we draw a `<path>` whose shape (`d`) is given by calling <mark class="purple">`line(series)`</mark>

* draw each tick given by <mark class="orange">`y.ticks()`</mark>, and a vertical line

* draw each tick given by <mark class="cyan">`x.domain()`</mark>, and a horizontal line

We're still using D3 to transform our data and prepare the functions that delivers it to us (eg. `x.domain()`), but we're drawing all of the SVG elements "ourselves" in Svelte.

Now, why is this better?

## Server-side rendering (SSR)

The first and most significant benefit is our charts can be **rendered on the server**. This means our chart is already present in the page's HTML when it lands in our reader's browser.

<aside>
  This is assuming you're using a tool to build your website that _does_ SSR, such as SvelteKit, Astro, or a custom setup using Svelte's SSR API.
</aside>

When we render charts using D3's DOM API inside `onMount`, as we saw before, we're asking Svelte to "wait until you land on the browser and finish rendering your HTML, before running this D3 code that draws a chart".

This comes with a number of drawbacks:

* <a href="https://developer.mozilla.org/en-US/docs/Glossary/CLS">cumulative layout shift</a> when our chart takes up the space it needs and moves neighbouring elements around

* more time before the chart appears, as the browser downloads the data required to draw the chart

* SEO penalties due to content not being initially available in the page, particularly if charts contain a lot of important content

We can mitigate these points individually, but it's much easier to just render the chart along with the rest of our page on the server.


## Animating charts with `svelte/transition`

Rendering our chart with Svelte opens the door to the rest of its powerful tools and functionality, like [`svelte/transition`](https://svelte.dev/docs/svelte/svelte-transition).

This library offers a bunch of functions that make it easy to transition elements when they're added or removed from the DOM.

One of these is the [`draw`](https://svelte.dev/docs/svelte/svelte-transition#draw) function. Let's see what it can do for our line chart.

<DrawTransitionsDemo />

Here, we're <mark class="purple">wrapping each `<path>` in an `{#if}` statement</mark> so they're all added to or removed from the DOM according to `showLines`. <mark class="orange">`in:draw`</mark> tells Svelte to animate the chosen element when it's _added_ to the DOM.

That <mark class="orange">`{{ delay: (i + 1) * 150 }}`</mark> bit is us giving parameters to the effect, adding an increasing delay to each of the five lines.

<aside>
  If you haven't seen `{@attach whenVisible(...)}` before, this is [Svelte's *attachments* feature](https://svelte.dev/docs/svelte/@attach), a really handy way of tucking away utilities like this that act on specific elements.

  This `whenVisible` attachment simply calls the given callback with true or false if the element is in the viewport.
</aside>

Alongside `draw`, there's also `fade`, `fly`, `slide`, and others, all of which can be used just as easily to add some flair to our visualisations.

## Reacting to changing data with runes

Rendering charts with Svelte also makes state management and reactivity easier, using Svelte 5's `$state` and `$derived` runes.

We used `$state` in the last example to show and hide our chart's lines, but let's look at a more involved example.

<ReactivityDemo />

Here, we're displaying three buttons that set the <mark class="purple">`stat`</mark> variable to <mark class="cyan">one of three strings</mark>. Each of these strings are properties in the `transfers` JSON data.

Using `$derived`, whenever <mark class="purple">`stat`</mark> changes:

* <mark class="orange">`maxStat`</mark> will become the maximum value of that property in the dataset
* <mark class="green">`line`</mark> will become a new line generator function for that property

And whenever <mark class="orange">`maxStat`</mark> changes:

* <mark class="red">`y`</mark> will become a generator function for the Y axis

Really, all we're doing is re-creating the D3 generator functions whenever we want to show different data, by making them _reactive variables_ using `$state` and `$derived`.

Notice that we haven't actually made any changes to the SVG-drawing code itself &mdash; we don't have to! Any HTML code that refers to <mark class="green">`line`</mark> and <mark class="red">`y`</mark> is automatically re-run when they change.

## Animating changes in data with `svelte/motion`

[`svelte/motion`](https://svelte.dev/docs/svelte/svelte-motion) is another one of Svelte's powerful extra libraries.

In this party bag, we have the [`Tween`](https://svelte.dev/docs/svelte/svelte-motion#Tween) tool, which gives us a reactive variable that smoothly changes from one value to another over time.

This works for numbers, but it also works for structured data, like objects and arrays.

Let's see what this can do for our chart.

<TweenDemo/>

There's a lot going on here: let's step through.

Whenever `stat` changes, `transfers.map((d) => ({ ...d, stat: d[stat] }))` is re-evaluated, returning the new dataset.

`Tween.of` takes this new dataset, and generates _a sequence of datasets_ that smoothly transition from the last value to the current.

<TweenData/>

<aside>
  `Tween` will only do this magic interpolation if it detects identical properties between the before and after structures.

  That's why we have to transform the transfers data to add a new `stat` property (`transfers.map((d) => ({ ...d, stat: d[stat] }))`), containing the data point we care about in each record.
</aside>

Over a period of 400 milliseconds (a default value), the tween rapidly steps through this sequence, setting `statData.current` with every step. `statData.current` is a reactive value, so whenever it changes, the `<path>`s are redrawn for the current dataset.

These steps happen very quickly. So quickly that all we see is a smooth morph animation between two charts.
