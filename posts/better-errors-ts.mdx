---
title: Better Error Handling in Typescript
created: "2023-02-02"
updated: "2023-02-02"
tags: ["typescript"]
readTimeMins: 5
status: live
intro: We don‚Äôt get much help from Typescript with error handling, but there are ways we can build on its features to make things easier for ourselves.
---

Compared to languages like Java and Python, Javascript/Typescript‚Äôs error handling features have always felt pretty half-baked to me.

Creating custom error types requires a bit of prototype fiddling, and handling errors in `catch` blocks feels much more primitive than it should be.

With this post I just wanted to share the snippets of code I‚Äôve brought to most of the Typescript projects I‚Äôve worked on, to solve these issues.

> üèÉ
> tl;dr: [see this Gist](https://gist.github.com/egargan-ft/0b54d27dd262740a8533d2d266db1116) for a better `Error` class and two functions to help tidy up your `catch` blocks

## A More Helpful `Error` Class

As you‚Äôll know if you‚Äôve ever wanted to create an `Error` subclass, there‚Äôs a bit of boilerplate needed in the constructor to do it ‚Äúproperly‚Äù.

We need to set the instance‚Äôs `name` property to the name of our error class.

As well, to make Typescript happy with our class, we need to explicitly set its prototype.

```tsx
export class MyError extends Error {
  constructor(message: string) {
    super(message);
		this.name = "MyError";
		Object.setPrototypeOf(this, MyError.prototype);
  }
}
```

It‚Äôs possible to create a base error class that abstracts all of this boilerplate, meaning its subclasses don‚Äôt need to bother, like so ‚Äî

```tsx
export class ExtError extends Error {
  constructor(message: string) {
    super(message);
    Object.defineProperty(this, "name", { value: new.target.name });
    Object.setPrototypeOf(this, new.target.prototype);
  }
}
```

This base error class just covers the basic issues I‚Äôve outlined above.

I‚Äôd use a library like [ts-custom-error](https://www.npmjs.com/package/ts-custom-error) if you want to add this to a serious codebase ‚Äî it does things a bit more officially, and also handles setting the `stack` property properly.

### Error Causes

TC39, the people that maintain the Javascript standard, recently implemented [their proposal to add a `cause` property to the base `Error` type](https://github.com/tc39/proposal-error-cause).

It‚Äôs been supported in Node since 16.9, and is implemented in every major browser, [according to MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error/cause#browser_compatibility).

This means you‚Äôll be able to give a `cause` property to `Error`'s constructor, like so ‚Äî

```tsx
try {
	somethingBad();
} catch (err) {
	throw new Error("something bad happened!", { cause: err });
}
```

When running in Node.js at least, we get a nice indented dump of the cause‚Äôs error stack.

```
% npx ts-node index.ts
/Users/edward.gargan/personal/ts-errors/index.ts:8
  throw new Error("something bad happened!", { cause: err });
        ^
Error: something bad happened!
    at Object.<anonymous> (/Users/edward.gargan/personal/ts-errors/index.ts:8:9)
    at Module._compile (node:internal/modules/cjs/loader:1165:14)
    ...
  [cause]: Error: ENOENT: no such file or directory, open 'doesnt-exist.txt'
      at Object.openSync (node:fs:590:3)
      at readFileSync (node:fs:458:35)
      at Object.<anonymous> (/Users/edward.gargan/personal/ts-errors/index.ts:5:28)
     ...
```

### Adding Causes to Subclasses

To attach a `cause` to subclasses of `Error`, you‚Äôd need to make sure to add a `cause` parameter to your subclass‚Äô constructor.

Or, something I‚Äôve found to be a bit cleaner, is to add a method to the base error class that sets the `cause` member after construction.

```tsx
export class ExtError extends Error {
  constructor(message: string) {
    super(message);
    Object.defineProperty(this, "name", { value: new.target.name });
    Object.setPrototypeOf(this, new.target.prototype);
  }

  from(cause: unknown): ExtError {
    this.cause = cause;
    return this;
  }
}
```

I‚Äôve not found any issues with this approach versus passing a `cause` to the `super` constructor ‚Äî assigning `cause` late doesn‚Äôt change how it‚Äôs handled by Node when it‚Äôs dumped out.

Note that you‚Äôll need to set your TS config‚Äôs `target` to at least `es2022` to stop it complaining about `this.cause = cause`.

## More Elegantly Handling Errors in `catch` Blocks

Javascript‚Äôs `catch` block is pretty boring. You catch an error, you give it a name, that‚Äôs all it lets you do.

Whereas in Python, for example, you can write many catch blocks, each dealing with one or a few specific error types.

```python
try:
  data = getData(filepath)
except IOError as err:
  log.warn("file could not be loaded", err);
except (ValueError, MissingValueError) as err:
  log.warn("file is corrupted", err);
```

We can achieve the same in Javascript with slightly clunkier code, using `instanceof` checks, as follows.

```jsx
try {
  data = getData(filepath);
} catch (err) {
	if (err instanceof FileError) {
	  log.warn("file could not be loaded", err);
	} else if (err instanceof TypeError | err instanceof MissingValueError) {
	  log.warn("file is corrupted", err);
	}
}
```

Another key feature of Python‚Äôs (and many other languages‚Äô) error handling is that errors ‚Äú**bubble up**‚Äù if they‚Äôre not explicitly caught.

In Javascript, we have to manually re-throw our errors at the end of the *every* `catch` block to get the same behaviour.

```jsx
try {
  data = getData(filepath);
} catch (err) {
	...
	} else {
		throw err;
	}
}
```

These two shortcomings led me to write these little `matchErr` and `matchErrOrThrow` functions that, for me, encourage safer and more thorough error handling.

Here‚Äôs how they look ‚Äî

```jsx
try {
  data = getData(filepath)
} catch (err) {
	if (matchErr(err, FileError)) {
	  log.warn("file could not be loaded", err);
	} else if (matchErrOrThrow(err, TypeError, MissingValueError)) {
	  log.warn("file is corrupted", err);
	}
}
```

As with `instanceof` checks, these functions will narrow `err` according to the given error types. E.g. within that `else if` block, `err`'s type will be `TypeError | MissingValueError`.

[See this Gist for the implementation of these functions](https://gist.github.com/egargan-ft/0b54d27dd262740a8533d2d266db1116).

## Throwing vs. Returning Error States

Having spent a bit of time with Rust, I quickly fell in love with its `Result` type, a container for either **an error type or a ‚Äúsuccessful‚Äù value type.

In either case, this `Result` is returned **from the function. Errors are never ‚Äúthrown‚Äù and ‚Äúcaught‚Äù as they are in Javascript.

Returning errors like this means *every path* through a function ‚Äî and so your program ‚Äî is type safe.

Using languages that throw errors, it can be difficult to cover all of the errors states that a function can produce, as you won‚Äôt be told if you haven‚Äôt handled a particular error (except in Java, which does check that you‚Äôve declared the exceptions that a function throws, and that you‚Äôve handled all of them when you call it).

There are plenty of libraries out there that give you a `Result` type for Typescript code, but without first-class language support for it like Rust has, it‚Äôs just not worth it, in my opinion.

Javascript‚Äôs error handling features are definitely lacking, but I‚Äôd rather use them than fight against the language and force my own patterns onto it.
